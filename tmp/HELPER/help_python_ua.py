01.md

## Тема уроку: представлення рядків у пам'яті комп'ютера, ASCII та Unicode
1. Подання рядків у пам'яті комп'ютера
2. Таблиця символів ASCII
3. Таблиця символів Unicode
4. Функція `ord()`
5. Функція `chr()`

**Аннотація**. Подання рядків у пам'яті комп'ютера.

<h2 align="center"><b>Подання рядків у пам'яті комп'ютера</b></h2>

Будь-який набір даних [оперативної пам'яті](https://ru.wikipedia.org/wiki/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C) комп'ютер повинен зберігатися у вигляді двійкового числа. Це стосується і рядків, які складаються із символів (літери, розділові знаки тощо). Коли символ зберігається в пам'яті, він спочатку перетворюється на цифровий код. І потім цей цифровий код зберігається у пам'яті як двійкове число.

За минулі роки для представлення символів у пам'яті комп'ютера розробили різні схеми кодування. Історично найважливішою із цих схем кодування є схема кодування ASCII (American Standard Code for Information Interchange – американський стандартний код обміну інформацією).

<h3 align="center"><b>Таблиця символів ASCII</b></h3>

ASCII є набором з 128 цифрових кодів, які позначають англійські літери, різні розділові знаки та інші символи. Наприклад, код ASCII для великої англійської літери "А" (латинської) дорівнює 65. Коли на комп'ютерній клавіатурі ви набираєте літеру "А" у верхньому реєстрі, у пам'яті зберігається число 65 (як двійкове число, зрозуміло).

<div align="center"><img src="https://ucarecdn.com/0e7a9757-5bae-4d65-a241-8910e1bf4e0f/" width="600"></div>

Код ASCII для англійської "В" у верхньому регістрі дорівнює 66, для "С" у верхньому регістрі - 67 і т. д. **На один символ в ASCII відводиться рівно 7 біт.**

> Абревіатура ASCll вимовляється "аскі".

<h3 align="center"><b>ASCII table</b></h3>

<div align="center"><img src="https://ucarecdn.com/8a6ce363-1e0c-4593-8c1b-f22da0dda956/"></div>

Набір символів ASCII був розроблений на початку 1960-х років і зрештою прийнятий майже всіма виробниками комп'ютерів. Однак схема кодування ASCII має обмеження, тому що визначає коди тільки для 128 символів. Для того, щоб це виправити, на початку 1990-х років було розроблено набір символів Юнікоду (Unicode). Це широка схема кодування, сумісна з ASCII, яка може представляти символи багатьох мов світу. Сьогодні Юнікод швидко стає стандартним набором символів, які використовуються в комп'ютерній індустрії.

<h3 align="center"><b>Таблиця символів Unicode</b></h3>

Таблиця символів Юнікод являє собою набір цифрових символів, які включають знаки майже всіх письмових мов світу. Стандарт запропонований 1991 року некомерційною організацією «Консорціум Юнікоду». Застосування цього стандарту дозволяє закодувати дуже багато символів з різних систем писемності: у документах, закодованих за стандартом Юнікод, можуть сусідити китайські ієрогліфи, математичні символи, літери грецького алфавіту, латиниці та кирилиці, символи музичної нотної нотації.

Стандарт складається з двох основних частин: універсального набору символів та сімейства кодувань (Unicode transformation format, UTF). Універсальний набір символів перераховує допустимі за стандартом Юнікод символи та надає кожному символу код у вигляді невід'ємного цілого числа. Сімейство кодувань визначає способи перетворення кодів символів для зберігання на комп'ютері та передачі.

У Юнікод весь час додаються нові символи, а сам розмір цієї таблиці не обмежений і тільки зростатиме, тому зараз при зберіганні в пам'яті одного юнікод-символу може знадобитися від 1 до 8 байт. Відсутність обмежень призвела до того, що почали з'являтися символи попри всі випадки життя.

> Python рядки зберігаються у вигляді послідовності юнікод символів.

<h3 align="center"><b>Примітки</b></h3>

**Примітки 1.** Офіційний сайт таблиці символів [Unicode](https://home.unicode.org/).

**Примітки 2.** Юнікод – це не кодування. Це таблиця символів. Те, як символи з відповідними кодами зберігатимуться в пам'яті комп'ютера, залежить від конкретного кодування, що базується на Юнікод, наприклад UTF-8. На відміну від таблиці символів Unicode від кодування UTF-8 можна почитати [тут](https://developer.roman.grinyov.name/blog/104).

**Примітки 3.** Перші 128 коди таблиці символів Unicode збігаються з ASCII.

<h2 align="center"><b>Функція ord</b></h2>

Функція `ord` дозволяє визначити код деякого символу у таблиці символів Unicode. Аргументом цієї функції є одиночний символ.

Результатом виконання наступного коду:
"""

num1 = ord('A')
num2 = ord('B')
num3 = ord('a')
print(num1, num2, num3)

"""Зверніть увагу, що функція `ord` приймає саме **одиничний символ**. Якщо спробувати передати рядок, що містить більше одного символу:

```python
num = ord('Abc')
print(num)
```

ми отримаємо помилку часу виконання:

`TypeError: ord() expected a character, but string of length 3 found`

> Назва функції `ord` походить від англійського слова order - порядок.

<h2 align="center"><b>Функція chr</b></h2>

Функція `chr` дозволяє визначити за кодом символу сам символ. Аргументом цієї функції є чисельний код.

Результатом виконання наступного коду:
"""

chr1 = chr(65)
chr2 = chr(75)
chr3 = chr(110)
print(chr1, chr2, chr3)

"""> Назва функції `chr` походить від англійського слова char – символ.

Функції `ord` та `chr` часто працюють у парі. Ми можемо використовувати наступний код для виведення всіх великих літер англійського алфавіту:

<h2 align="center"><b>Примітки</b></h2>

**Примітка.** Функції ord і chr є **взаємно зворотними**. Для них виконані рівність:

```python
chr(ord('A')) = 'A', ord(chr(65)) = 65.
```

# Списки

## Тема уроку: введення до списків

1. Створення списків
2. Порожні списки
3. Вбудована функція `list()`
4. Виведення списків

**Аннотація.** Списки як збереження послідовностей та аналог масивів.

<h2 align="center"><b>Списки</b></h2>

У попередніх уроках ми працювали з послідовностями чисел, символів, рядків, але не зберігали всю послідовність у пам'яті комп'ютера, а обробляли її поелементно, зчитуючи щоразу новий елемент. Однак у багатьох завданнях потрібно зберігати всю послідовність. Наприклад, класичне завдання [сортування](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8) (упорядкування) певної послідовності вимагає збереження всіх даних у пам'яті комп'ютера. На жаль, не зберігши їх неможливо відсортувати. І тут на допомогу приходить структура даних, яка у більшості мов програмування називається [масивом](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%81%D1%81%D0%B8%D0%B2_(%D1%82%D0%B8%D0%BF_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)). У Python вона називається **списком**.

> Структура даних (data structure) — програмна одиниця, що дозволяє **зберігати та обробляти** безліч однотипних та/або логічно пов'язаних даних.

Список є послідовністю елементів, пронумерованих від 0, як символи в рядку.

<h3 align="center"><b>Створення списку</b></h3>

Щоб створити список, потрібно перерахувати його елементи через кому у квадратних дужках:

```python
numbers = [2, 4, 6, 8, 10]
languages = ['Python', 'C#', 'C++', 'Java']
```

Список numbers складається з 5 елементів, і кожен із них — ціле число.

* `numbers[0] == 2;`
* `numbers[1] == 4;`
* `numbers[2] == 6;`
* `numbers[3] == 8;`
* `numbers[4] == 10.`

Список languages складається з 4 елементів, кожен з яких рядок.

* `languages[0] == 'Python';`
* `languages[1] == 'C#';`
* `languages[2] == 'C++';`
* `languages[3] == 'Java'.`

> Значення, укладені у квадратні дужки та відокремлені комами, називаються **елементами списку**.

Список може містити значення **різних типів даних:**

```python
info = ['Timur', 1992, 61.5]
```

Список `info` містить рядкове значення, ціле число та число з плаваючою точкою.

* `info[0] == 'Bender';`
* `info[1] == 1992;`
* `info[2] == 61.5.`

> Зазвичай елементи списку містять дані одного типу і практично рідко доводиться створювати списки містять елементи різних типів даних.

<h3 align="center"><b>Порожній список</b></h3>

Створити порожній список можна двома способами:

1. Використовувати порожні квадратні дужки `[]`;
2. Використовувати вбудовану функцію, яка називається `list`.

Наступні два рядки коду створюють порожній список:

```python
mylist = []       # порожній список
mylist = list()   # порожній список
```

<h3 align="center"><b>Виведення списку</b></h3>

Для виведення всього списку можна застосувати функцію `print()`:

```python
numbers = [2, 4, 6, 8, 10]
languages = ['Python', 'C#', 'C++', 'Java']
print(numbers)
print(languages)
```

Функція `print()` виводить на екран елементи списку, у квадратних дужках, розділені комами:

```python
[2, 4, 6, 8, 10]
['Python', 'C#', 'C++', 'Java']
```

> Зверніть увагу, що виведення списку містить квадратні дужки. Пізніше ми навчимося виводити елементи списку зручнішому вигляді з допомогою циклів.

<h3 align="center"><b>Вбудована функція list</b></h3>

Python має вбудовану функцію `list()`, яка, крім створення порожнього списку, може перетворювати деякі типи об'єктів у списки.

Наприклад, ми знаємо, що функція `range()` створює послідовність цілих чисел у заданому діапазоні. Для перетворення цієї послідовності на список, ми пишемо наступний код:

```python
numbers = list(range(5))
```

Під час виконання цього коду відбувається таке:

1. Викликається функція range(), яку як аргумент передається число 5;
2. Ця функція повертає послідовність чисел 0, 1, 2, 3, 4;
3. Послідовність чисел 0, 1, 2, 3, 4 передається як аргумент у функцію list();
4. Функція `list()` повертає перелік [0, 1, 2, 3, 4];
5. Список [0, 1, 2, 3, 4] присвоюється змінною numbers.

Ось ще один приклад:

```python
even_numbers = list(range(0, 10, 2))  # список містить парні числа 0, 2, 4, 6, 8
odd_numbers = list(range(1, 10, 2))   # список містить непарні числа 1, 3, 5, 7, 9
```

Так само за допомогою функції `list()` ми можемо створити список із символів рядка. Для перетворення рядка на список ми пишемо наступний код:

```python
s = 'abcde'
chars = list(s)  # список містить символи 'a', 'b', 'c', 'd', 'e'
```

Під час виконання цього коду відбувається таке:

1. Викликається функція list(), яку як аргумент передається рядок 'abcde';
2. Функція list() повертає список ['a', 'b', 'c', 'd', 'e'];
3. Список ['a', 'b', 'c', 'd', 'e'] надається змінною chars.

<h2 align="center"><b>Примітки</b></h2>

**Примітка 1**. Як уже було сказано, списки Python аналогічні масивам в інших мовах програмування. Однак різниця між списками і масивами все ж таки існує. Елементи масиву завжди мають однаковий тип даних і розташовуються в пам'яті комп'ютера безперервним блоком, а елементи списку можуть бути розкидані пам'яті як завгодно і можуть мати різний тип даних.

**Примітка 2**. Зверніть увагу, при виведенні вмісту списку за допомогою функції `print()` всі рядкові елементи списку обрамляються **одинарними лапками**. Якщо потрібно зробити висновок у подвійних лапках, потрібно самостійно писати код виведення.

## Тема уроку: основи роботи зі списками

1. Вбудовані функції `len()`, `sum()`, `min()`, `max()`
2. Оператор приладдя in
3. Індексація та зрізи
4. Конкатенація та множення на число
5. Відмінність списків від рядків

**Аннотація**. Починаємо працювати зі списками.

<h2 align="center"><b>Основи роботи зі списками</b></h2>

Робота зі списками дуже сильно нагадує роботу з рядками, оскільки списки і рядки містять окремі елементи: елементи списку можуть мати довільний тип, а елементами рядків завжди є символи. Багато чого з того, що ми робили з рядками, є доступним і при роботі зі списками.

<h3 align="center"><b>Функція len()</b></h3>

**Довжиною списку** називається кількість його елементів. Для того, щоб порахувати довжину списку, ми використовуємо вбудовану функцію `len()` (від слова length – довжина).

Наступний програмний код:
"""

numbers = [2, 4, 6, 8, 10]
languages = ['Python', 'C#', 'C++', 'Java']

print(len(numbers))      # виводимо довжину списку numbers
print(len(languages))    # виводимо довжину списку languages

print(len(['apple', 'banana', 'cherry']))   # виводимо довжину списку, що складається з 3 елементів

"""<h3 align="center"><b>Оператор приладдя in</b></h3>

Оператор in дозволяє перевірити, чи список містить певний елемент.

Розглянемо наступний код:

```python
numbers = [2, 4, 6, 8, 10]

if 2 in numbers:
    print('Список number містить число 2')
else:
    print('Список numbers не содержит число 2')
```

Такий код перевіряє, чи містить список numbers число 2 і виводить відповідний текст:

`Список number містить число 2`

Ми можемо використовувати оператор in разом із логічним оператором not. Наприклад

```python
numbers = [2, 4, 6, 8, 10]

if 0 not in numbers:
    print('Список numbers не містить нулів')
```

<h3 align="center"><b>Індексація</b></h3>

Під час роботи з рядками ми використовували **індексацію**, тобто звернення до конкретного символу рядка за його індексом. Аналогічно можна індексувати і списки.

Для індексації списків Python використовуються квадратні дужки `[]`, в яких вказується індекс (номер) потрібного елемента в списку:

Нехай `numbers = [2, 4, 6, 8, 10]`.

Таблиця нижче, показує як працює індексація:

Вираз | Результат | Пояснення
--|--|--
numbers[0] |	2 |	перший елемент списку
numbers[1] |	4 |	другий елемент списку
numbers[2] |	6 |	третій елемент списку
numbers[3] |	8 |	четвертий елемент списку
numbers[4] |	10 |	п'ятий елемент списку

> Зверніть увагу на перший елемент списку `numbers[0]`, а не `numbers[1]`.

Так само, як і в рядках, для нумерації з кінця дозволено негативні індекси.

Вираз | Результат | Пояснення
--|--|--
numbers[-1] |	10 |	пятый элемент списка
numbers[-2] |	8 |	четвертий елемент списку
numbers[-3] |	6 |	третий элемент списка
numbers[-4] |	4 |	другий елемент списку
numbers[-5] |	2 |	перший елемент списку

Як і в рядках, спроба звернутися до елемента списку за неіснуючим індексом:

```python
print(numbers[17])
```

викличе помилку:

`IndexError: index out of range`

<h3 align="center"><b>Зрізи</b></h3>

Розглянемо список `numbers = [2, 4, 6, 8, 10]`.

За допомогою зрізу ми можемо отримати кілька елементів списку, створивши діапазон індексів розділених двокрапкою `numbers[x:y]`.

Наступний програмний код:
"""

print(numbers[1:3])
print(numbers[2:5])

"""При побудові зрізу `numbers[x:y]` перше число – це місце, де починається зріз (**включно**), а друге – це місце, де закінчується зріз (**невключно**). Розрізаючи списки, ми створюємо нові списки по суті підсписки вихідного.

При використанні зрізів зі списками ми також можемо опускати другий параметр у зрізі `numbers[x:]` (але поставити двокрапку), тоді зріз береться до кінця списку. Аналогічно якщо опустити перший параметр `numbers[:y]`, можна взяти зріз від початку списку.

> Зріз `numbers[:]` повертає копію вихідного списку.

Як і рядки, ми можемо використовувати негативні індекси в зрізах списків.

<h3 align="center"><b>Використання зрізів для зміни елементів у заданому діапазоні</b></h3>

Для зміни цілого діапазону елементів списку можна використати зрізи. Наприклад, якщо ми хочемо перекласти на російську мову назви фруктів `'banana'`, `'cherry'`, `'kiwi'`, то це можна зробити за допомогою зрізу.

Наступний програмний код:
"""

fruits = ['apple', 'apricot', 'banana', 'cherry', 'kiwi', 'lemon', 'mango']
fruits[2:5] = ['банан', 'вишня', 'ківи']

print(fruits)

"""<h3 align="center"><b>Операція конкатенації + та множення на число *</b></h3>

Ми можемо використовувати оператори + та * для списків подібно до того, як ми це робили з рядками.

Наступний програмний код:
"""

print([1, 2, 3, 4] + [5, 6, 7, 8])
print([7, 8] * 3)
print([0] * 10)

"""Для генерації списків, що складаються строго з елементів, що повторюються, множення на число - найкоротший і правильний метод.

Ми також можемо використовувати розширені оператори `+=` та `*=` під час роботи зі списками.

Наступний програмний код:
"""

a = [1, 2, 3, 4]
b = [7, 8]
a += b   # додаємо до списку a список b
b *= 5   # повторюємо список b 5 разів

"""<h3 align="center"><b>Вбудовані функції sum(), min(), max()</b></h3>

Вбудована функція `sum()` приймає як параметр список чисел та обчислює суму його елементів.

Наступний програмний код:
"""

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print('Сума всіх елементів списку =', sum(numbers))

"""Вбудовані функції `min()` і `max()` приймають як параметр список і знаходять мінімальний та максимальний елементи відповідно.

Наступний програмний код:
"""

numbers = [3, 4, 10, 3333, 12, -7, -5, 4]
print('Мінімальний елемент =', min(numbers))
print('Максимальний елемент =', max(numbers))

"""<h2 align="center"><b>Відмінність списків від рядків</b></h2>

Незважаючи на всю схожість списків і рядків, є одна дуже важлива відмінність: рядки - **незмінювані** об'єкти, а списки - **змінювані**.

Наступний програмний код:

```python
s = 'abcdefg'
s[1] = 'x'    # намагаємося змінити 2 символ (за індексом 1) рядка
```

призводить до помилки:

`object does not support item assignment`

Наступний програмний код:




"""

numbers = [1, 2, 3, 4, 5, 6, 7]
numbers[1] = 101     # змінюємо 2 елемент (за індексом 1) списку
print(numbers)

"""> **Запам'ятай**: не можна змінювати окремі символи рядків, однак можна змінювати окремі елементи списків. Для цього використовуємо індексатор та оператор присвоювання.

## Тема уроку: методи додавання та видалення елементів

1. Метод додавання елемента `append()`
2. Метод розширення списку `extend()`
3. Оператор `del`
4. Розв'язання задач

**Аннотація**. Додавання елементів до списку. Оператор `del`, що видаляє елементи за заданим індексом.

<h2 align="center"><b>Додавання елементів</b></h2>

Ми навчилися створювати статичні списки, тобто, списки, елементи яких відомі на етапі створення. Наступний крок – навчитися додавати елементи до вже існуючих списків.

<h3 align="center"><b>Метод append()</b></h3>

Для додавання нового елемента **наприкінці** списку використовується метод `append()`.

Наступний програмний код:
"""

numbers = [1, 1, 2, 3, 5, 8, 13]  # створюємо список

numbers.append(21)  # додаємо число 21 до кінця списку
numbers.append(34)  # додаємо число 34 до кінця списку

print(numbers)

"""Зверніть увагу, щоб використовувати метод append(), потрібно, щоб список був створений, при цьому він може бути порожнім.

Наступний програмний код:
"""

numbers = []  # створюємо порожній список

numbers.append(1)
numbers.append(2)
numbers.append(3)

print(numbers)

"""> **Важливо**: ми не можемо використовувати індексатори для встановлення значень елементів списку, якщо список є порожнім. Наступний програмний код:

```python
numbers = []  # створюємо порожній список

numbers[0] = 1
numbers[1] = 2
numbers[2] = 3

print(numbers)
```

призводить до помилки:

`IndexError: list assignment index out of range`

<h3 align="center"><b>Метод extend()</b></h3>

Можна також розширити список іншим списком шляхом виклику методу extend().

Наступний програмний код:
"""

numbers = [0, 2, 4, 6, 8, 10]
odds = [1, 3, 5, 7]

numbers.extend(odds)
print(numbers)

"""Метод `extend()` хіба що розширює один список, додаючи щодо нього елементи іншого списку.

Відмінність між методами `append()` та `extend()` проявляється при додаванні рядка до списку.

Наступний програмний код:
"""

words1 = ['iq option', 'stepik', 'beegeek']
words2 = ['iq option', 'stepik', 'beegeek']

words1.append('python')
words2.extend('python')

print(words1)
print(words2)

"""Метод `append()` додає рядок ``python'` до списку, а метод `extend()` розбиває рядок `'python'` на символи `'p', 'y', 't', 'h', 'o', 'n'` і їх додає як елемент списку.

<h2 align="center"><b>Видалення елементів</b></h2>

За допомогою оператора `del` можна видаляти елементи списку за певним індексом.

Наступний програмний код:
"""

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
del numbers[5]    # видаляємо елемент, що має індекс 5

print(numbers)

"""Елемент під зазначеним індексом видаляється, а перелік перебудовується.

> Зверніть увагу на синтаксис видалення, оскільки він відрізняється від звичайного методу виклику. При видаленні елементів не потрібно передавати аргумент усередині круглих дужок.

Оператор `del` працює і зі зрізами: ми можемо вилучити цілий діапазон елементів списку.

Наступний програмний код:
"""

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
del numbers[2:7]    # видаляємо елементи з 2 по 6 включно

print(numbers)

"""Ми можемо видалити всі елементи на парних позиціях (0, 2, 4, ...) вихідного списку.

Наступний програмний код:
"""

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
del numbers[::2]

print(numbers)

"""<h2 align="center"><b>Виведення елементів списку</b></h2>

При виведенні вмісту списку за допомогою функції `print()` виведення елементів здійснюється у квадратних дужках, причому всі елементи розділені комою. Такий висновок не завжди зручний і переважний, тому потрібно вміти виводити елементи списку потрібним способом.

<h3 align="center"><b>Виведення за допомогою циклу for</b></h3>

Для виведення елементів списку **кожного на окремому рядку** можна використовувати наступний код:

**Варіант 1**. Якщо потрібні індекси елементів:

```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

for i in range(len(numbers)):
    print(numbers[i])
```

Ми передаємо у функцію `range()` довжину списку `len(numbers)`. У нашому випадку довжина списку `numbers` дорівнює 11. Таким чином виклик функції `range(len(numbers))` має вигляд `range(11)` і змінна циклу i послідовно перебирає всі значення від 0 до 10. Це означає, що вираз `numbers[i]` послідовно поверне всі елементи списку `numbers`. Такий спосіб ітерації списку зручний, коли нам потрібен не тільки сам елемент `numbers[i]`, але його індекс `i`.

**Вариант 2**. Якщо індекси не потрібні:

```puthon
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

for num in numbers:
    print(num)
```

Цей цикл пройде за списком `numbers`, надаючи змінної циклу `num` значення кожного елемента списку (!) на відміну попереднього циклу, у якому змінна циклу «бігала» за індексами списку.

Якщо потрібно виводити елементи списку на одному рядку через пробіл, то ми можемо використовувати необов'язковий параметр `end` функції `print()`:
"""

numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

for num in numbers:
    print(num, end=' ')

"""<h3 align="center"><b>Висновок за допомогою розпакування списку</b></h3>

Python має зручний спосіб виведення елементів списку без використання циклу `for`.

**Варіант 1**. Виведення елементів списку через один символ пропуску:
"""

numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

print(*numbers)

"""**Варіант 2**. Виведення елементів списку кожного на окремому рядку"""

numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

print(*numbers, sep='\n')

"""Оскільки рядки містять символи, подібно до того, як списки містять елементи, то ми можемо використовувати розпакування рядків так само, як і розпакування списків.

Такий код:
"""

s = 'Python'

print(*s)
print()
print(*s, sep='\n')

"""## Тема уроку: рядкові методи

1. Метод split()
2. Метод join()

**Аннотація**. Строкові методи `split()` та `join()`.

У попередньому модулі ми детально вивчили основні рядкові методи, проте обійшли стороною два важливі: `split()` і `join()`, що стосуються списків. Вони як би протилежні за змістом: метод `split()` розбиває рядок по довільному роздільнику на список слів, а метод `join()` збирає рядок зі списку слів через заданий роздільник.

<h2 align="center"><b>Метод split()</b></h2>

Метод `split()` розбиває рядок на слова, використовуючи як роздільник послідовність пробільних символів.

Наступний програмний код:
"""

s = 'Python is the most powerful language'
words = s.split()
print(words)

"""<div align="center"><img src="https://raw.githubusercontent.com/steamcentre/python_book/main/img/09.png"></div>

Таким чином, виклик методу `split()` розбиває рядок на слова та повертає список, що містить усі слова.

Розглянемо наступний програмний код:

```python
numbers = input().split()
```

Якщо запуск цієї програми ввести рядок `1 2 3 4 5`, то список numbers буде наступним `['1', '2', '3', '4', '5']`. Зверніть увагу, що список буде складатися з рядків, а не з чисел. Якщо потрібно отримати саме список чисел, потім потрібно елементи списку по одному перетворити в числа:

```python
numbers = input().split()
for i in range(len(numbers)):
    numbers[i] = int(numbers[i])
```

<h3 align="center"><b>Необов'язковий параметр</b></h3>

Метод `split()` має необов'язковий параметр, який визначає, який набір символів буде використовуватися як роздільник між елементами списку. Наприклад, виклик методу `split('.')` поверне список, отриманий поділом вихідного рядка за символом ``.'`.

Наступний програмний код:
"""

ip = '192.168.1.24'
numbers = ip.split('.')    # вказуємо явно роздільник
print(numbers)

"""<div align="center"><img src="https://raw.githubusercontent.com/steamcentre/python_book/main/img/10.png"></div>

<h2 align="center"><b>Метод join()</b></h2>

Метод `join()` збирає рядок з елементів списку, використовуючи як роздільник рядок, до якого застосовується метод.

Наступний програмний код:
"""

words = ['Python', 'is', 'the', 'most', 'powerful', 'language']
s = ' '.join(words)
print(s)

"""<div align="center"><img src="https://raw.githubusercontent.com/steamcentre/python_book/main/img/11.png"></div>

Зверніть увагу, всі слова розділені одним пробілом, оскільки метод `join()` викликався на рядку, що складається з одного символу пробілу `' '`.

Розглянемо ще кілька прикладів:
"""

words = ['Ми', 'вивчаємо', 'мову', 'Python']
print('*'.join(words))
print('-'.join(words))
print('?'.join(words))
print('!'.join(words))
print('*****'.join(words))
print('abc'.join(words))
print('123'.join(words))

"""**Запам'ятай**: Рядковий метод `split()` служить для перетворення рядка в список, а метод `join()` - для перетворення списку в рядок.

<h2 align="center"><b>Примітки</b></h2>

**Примітка 1**. Існує велика різниця між результатами виклику методів `s.split()` та `s.split(' ')`. Різниця в поведінці проявляється, коли рядок містить кілька пробілів між словами.

Наступний програмний код:
"""

s = 'Python    is   the  most  powerful  language'
words1 = s.split()
words2 = s.split(' ')
print(words1)
print(words2)

"""**Примітка 2**. Методи `split()` та `join()` є рядковими методами. Наступний код призводить до помилки:

```python
print([1, 2].split())
print([1, 2].join([3, 4, 5]))
```

**Примітка 3**. Рядковий метод `join()` працює тільки зі списком рядків. Наступний код призводить до помилки:

```python
numbers = [1, 2, 3, 4]  # список чисел
s = '*'.join(numbers)
print(s)
```

## Тема уроку: методи списків

1. Метод insert()
2. Метод index()
3. Метод remove()
4. Метод pop()
5. Метод reverse()
6. Метод count()
7. Метод clear()
8. Метод copy()
9. Метод sort()

**Аннотація**. Інші способи списків.

Ми вже познайомилися з двома списковими методами `append()` та `extend()`. Перший додає до кінця списку один новий елемент, а другий розширює список іншим списком. До списків у Python застосовні інші зручні методи, з якими ми познайомимося в цьому уроці.

<h2 align="center"><b>Метод insert()</b></h2>

Метод `insert()` дозволяє вставляти значення до списку в заданій позиції. У нього передається два аргументи:

1. `index`: індекс, який задає місце вставки значення;
2. `value`: значення, яке потрібно вставити.

Коли значення вставляється в список, список розширюється розміром, щоб розмістити нове значення. Значення, яке раніше знаходилося в заданій індексній позиції, і всі елементи після нього зсуваються однією позицію до кінця списку.

Наступний програмний код:
"""

names = ['Gvido', 'Roman' , 'Timur']
print(names)
names.insert(0, 'Anders')
print(names)
names.insert(3, 'Josef')
print(names)

"""Якщо вказано неприпустимий індекс, під час виконання програми не відбувається помилки. Якщо заданий індекс за межами кінця списку, значення буде додано в кінець списку. Якщо застосований негативний індекс, який вказує на неприпустиму позицію, значення буде вставлено на початок списку.

<h2 align="center"><b>Метод index()</b></h2>

Метод `index()` повертає індекс першого елемента, значення якого дорівнює переданому методу значенню. Таким чином, метод передається один параметр:

1. `value`: значення, індекс якого потрібно знайти.
Якщо елемент у списку не знайдено, під час виконання відбувається помилка.

Наступний програмний код:
"""

names = ['Gvido', 'Roman' , 'Timur']
position = names.index('Timur')
print(position)

"""Наступний програмний код:

```python
names = ['Gvido', 'Roman' , 'Timur']
position = names.index('Anders')
print(position)
```

призводить до помилки:


Щоб уникнути таких помилок, можна використовувати метод index() разом із оператором приналежності `in`:

```python
names = ['Bender', 'Fry' , 'Zoidberg']
if 'Anders' in names:
    position = names.index('Leela')
    print(position)
else:
    print('Такого значення немає у списку')
```

<h2 align="center"><b>Метод remove()</b></h2>

Метод `remove()` видаляє перший елемент, значення якого дорівнює переданому метод значенням. У метод передається один параметр:

1. `value`: значення, яке потрібно видалити.

Метод зменшує розмір списку однією елемент. Всі елементи після віддаленого елемента зміщуються на одну позицію на початок списку. Якщо елемент у списку не знайдено, під час виконання відбувається помилка.

Наступний програмний код:
"""

food = ['Рис', 'Курка', 'Риба', 'Брокколі', 'Рис']
print(food)
food.remove('Рис')
print(food)

"""**Важливо**: метод `remove()` видаляє лише перший елемент із зазначеним значенням. Усі його входження залишаються у списку. Щоб видалити всі входження потрібно використовувати цикл `while` у зв'язці з оператором приналежності `in` та методом `remove`.

<h2 align="center"><b>Метод pop()</b></h2>

Метод `pop()` видаляє елемент за вказаним індексом та повертає його. У метод `pop()` передається один **необов'язковий** аргумент:

1. `index`: індекс елемента, який потрібно видалити.

Якщо індекс не вказано, метод видаляє і повертає останній елемент списку. Якщо список порожній або вказаний індекс за межами діапазону, під час виконання відбувається помилка.

Наступний програмний код:
"""

names = ['Bender', 'Fry' , 'Zoidberg']
item = names.pop(1)
print(item)
print(names)

"""<h2 align="center"><b>Метод count()</b></h2>

Метод `count()` повертає кількість елементів у списку, значення яких дорівнюють переданому в метод значенню.

Таким чином, метод передається один параметр:

1. `value`: значення, кількість елементів, рівних якому потрібно порахувати.

Якщо значення списку не знайдено, то метод повертає 0.

Наступний програмний код:

"""

names = ['Bender', 'Fry' , 'Bender', 'Leela', 'Bender']
cnt1 = names.count('Bender')
cnt2 = names.count('Fry')
cnt3 = names.count('Amy')

print(cnt1)
print(cnt2)
print(cnt3)

"""<h2 align="center"><b>Метод reverse()</b></h2>

Метод `reverse()` інвертує порядок проходження значень у списку, тобто змінює його на протилежний.

Наступний програмний код:
"""

names = ['Bender', 'Fry' , 'Zoidberg']
names.reverse()
print(names)

"""> Існує велика різниця між викликом методу names.reverse() та використанням зрізу `names[::-1]`. Метод `reverse()` змінює порядок елементів на зворотний **у поточному списку**, а зріз створює копію списку, в якому елементи слідують у зворотному порядку.

<h2 align="center"><b>Метод clear()</b></h2>

Метод clear() видаляє всі елементи зі списку.

Наступний програмний код:
"""

names = ['Bender', 'Fry' , 'Zoidberg']
names.clear()
print(names)

"""<h2 align="center"><b>Метод copy()</b></h2>

Метод `copy()` створює поверхневу копію списку.

Наступний програмний код:
"""

names = ['Bender', 'Fry' , 'Zoidberg']
names_copy = names.copy()              # створюємо поверхневу копію списку names

print(names)
print(names_copy)

"""Аналогичного результата можно достичь с помощью срезов или функции `list()`:

```python
names = ['Bender', 'Fry' , 'Zoidberg']
names_copy1 = list(names)             # створюємо поверхневу копію за допомогою функції list()
names_copy2 = names[:]                # створюємо поверхневу копію за допомогою зрізу від початку до кінця
```

<h2 align="center"><b>Примітки</b></h2>

**Примітка**. Існує велика різниця у роботі рядкових та спискових методів. Строкові методи не змінюють вмісту об'єкта якого вони застосовуються, а повертають нове значення. Облікові методи, навпаки, змінюють вміст об'єкта якого застосовуються.

<h2 align="center"><b>Метод sort()</b></h2>

У Python списки мають вбудований метод `sort()`, який сортує елементи списку за зростанням або спаданням.

Наступний програмний код:
"""

a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6,  8, -2, 99]
a.sort()
print('Відсортований список:', a)

"""За умовчанням метод `sort()` сортує список за зростанням. Якщо потрібно відсортувати список за спаданням, необхідно явно вказати параметр `reverse = True`.

Наступний програмний код:
"""

a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6,  8, -2, 99]
a.sort(reverse = True)   # сортуємо за спаданням
print('Відсортований список:', a)

"""<h2 align="center"><b>Примітки</b></h2>

**Примітка 1**. За допомогою методу `sort()` можна сортувати списки, що містять не тільки числа, а й рядки. У такому разі елементи списку сортуються відповідно до лексикографічного [порядку](https://ru.wikipedia.org/wiki/%D0%9B%D0%B5%D0%BA%D1%81%D0%B8%D0%BA%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA).

Наступний програмний код:
"""

a = ['бета', 'альфа', 'дельта', 'гамма']
a.sort()
print ('Відсортований список:', a)

"""**Примітка 2**. Метод `sort()` використовує алгоритм [Timsort](https://ru.wikipedia.org/wiki/Timsort).

## Тема уроку: спискові вирази

1. Облікові вирази
2. Розв'язання задач

**Аннотація**. Облікові вирази. Створення списків без використання циклів і виклику спискового методу append().

<h2 align="center"><b>Створення списків</b></h2>

Для того, щоб створити список, що складається з 1010 нулів, ми можемо використовувати наступний код:

```python
zeros = []
for i in range(10):
    zeros.append(0)
```

У Python, однак, є більш простий і компактний спосіб для створення такого списку. Ми можемо використовувати оператор множення списку на число:

```python
zeros = [0] * 10
```

Для створення списків, заповнених за складнішими правилами, нам доводиться явно використовувати цикл `for`.

Наприклад, для створення списку цілих чисел від 00 до 99 ми змушені писати такий код:

```python
numbers = []
for i in range(10):
    numbers.append(i)
```

Такий код хоч і не складний, проте досить громіздкий.

<h2 align="center"><b>Облікові висловлювання</b></h2>

Python має механізм для створення списків з неповторних елементів. Такий механізм називається **обліковий вираз** (list comprehension).

Попередній код можна записати так:

```python
numbers = [i for i in range(10)]
```

Загальний вигляд облікового виразу наступний:

`[вираз for змінна in послідовність]`

де `змінна` - ім'я деякої змінної, `послідовність` - послідовність значень, які вона набуває (список, рядок або об'єкт, отриманий за допомогою функції `range`), `вираз` - деякий вираз, як правило, що залежить від використаної у списковому виразі змінної, яким будуть заповнені елементи списку.

<h3 align="center"><b>Приклади використання спискових виразів</b></h3>

**1. Створити список, заповнений 10 нулями, можна і за допомогою облікового виразу:**

```python
zeros = [0 for i in range(10)]
```

**2. Створити список, заповнений квадратами цілих чисел від 0 до 9, можна так:**

```python
squares = [i ** 2 for i in range(10)]
```

**3. Створити список, заповнений кубами цілих чисел від 10 до 20, можна так:**

```python
cubes = [i ** 3 for i in range(10, 21)]
```

**4. Створити список, наповнений символами рядка:**

```python
chars = [c for c in 'abcdefg']
print(chars)
```

<h3 align="center"><b>Зчитування вхідних даних</b></h3>

При вирішенні багатьох завдань із попередніх уроків ми зчитували початкові дані (рядки, числа) та заповнювали ними список. За допомогою облікових виразів процес заповнення списку можна помітно скоротити.

Наприклад, якщо спочатку вводиться число `n` – кількість рядків, а потім самі рядки, створити список можна так:

```python
n = int(input())
lines = [input() for _ in range(n)]
```

Можна опустити опис змінної `n`:

```python
lines = [input() for _ in range(int(input()))]
```

Якщо потрібно рахувати список чисел, необхідно додати перетворення типів:

```python
numbers = [int(input()) for _ in range(int(input()))]
```

Зверніть увагу, ми використовуємо символ `_` як ім'я змінної циклу, оскільки вона не використовується.

> Облікові висловлювання часто використовуються для ініціалізації списків. У Python не прийнято створювати порожні списки, а потім заповнювати їх значеннями, якщо цього можна уникнути.

<h3 align="center"><b>Умови у списковому виразі</b></h3>

У спискових висловлюваннях можна використовувати умовний оператор. Наприклад, якщо потрібно створити список парних чисел від 0 до 20, ми можемо написати такий код:

```python
evens = [i for i in range(21) if i % 2 == 0]
```

> **Важливо**: щоб отримати список, що складається з парних чисел, краще використовувати функцію `range(0, 21, 2)`. Попередній приклад наведено для демонстрації можливості використання умов у спискових виразах.

<h3 align="center"><b>Вкладені цикли</b></h3>

У списку можна використовувати вкладені цикли.

Наступний програмний код:
"""

numbers = [i * j for i in range(1, 5) for j in range(2)]
print(numbers)

"""Такий код рівнозначний такому:

```python
numbers = []

for i in range(1, 5):
    for j in range(2):
        numbers.append(i * j)
print(numbers)
```

<h3 align="center"><b>Підводячи підсумок</b></h3>

Нехай `word = 'Hello', numbers = [1, 14, 5, 9, 12], words = ['one', 'two', 'three', 'four', 'five', 'six']`.

Обліковий вираз | Результуючий список
--|--
`[0 for i in range(10)]` |	`[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]`
`[i ** 2 for i in range(1, 8)]` |	`[1, 4, 9, 16, 25, 36, 49]`
`[i * 10 for i in numbers]` |	`[10, 140, 50, 90, 120]`
`[c * 2 for c in word]` |	`['HH', 'ee', 'll', 'll', 'oo']`
`[m[0] for m in words]` |	`['o', 't', 't', 'f', 'f', 's']`
`[i for i in numbers if i < 10]` |	`[1, 5, 9]`
`[m[0] for m in words if len(m) == 3]` |	`['o', 't', 's']`

## Тема урока: сортировка списков

Урок за [посиланням](https://stepik.org/lesson/310445/step/1)

# Функції

## Тема уроку: функції користувача

1. Функції без параметрів
2. Переваги використання функцій
3. Ключове слово pass
4. Розв'язання задач

**Аннотація**. Створення функцій користувача без параметрів.

<h3 align="center"><b>Функції</b></h3>

У попередніх уроках ми використовували вбудовані в Python функції `print(), input(), int(), str(), len()` та багато інших. Настав час почати писати власні функції.

На самому початку курсу вам було запропоновано вирішити завдання, в якому потрібно зобразити зоряний прямокутник розмірами 5 × 7 (5 рядків та 7 стовпців).

Наш перший варіант коду виглядав приблизно так:

```python
print('*******')
print('*******')
print('*******')
print('*******')
print('*******')
```

Далі ми вивчили оператор множення рядка на число (оператор повторення) та написали б код:


```python
print('*' * 7)
print('*' * 7)
print('*' * 7)
print('*' * 7)
print('*' * 7)
```

Ну і нарешті, ми вивчили цикли, після чого код набув би вигляду:

```python
for _ in range(5):
    print('*' * 7)
```

А тепер уявімо, що таких прямокутників потрібно зобразити не один, а кілька, скажімо 3 штуки.

Тоді код програми матиме вигляд:
"""

for _ in range(5):
    print('*' * 7)

print()

for _ in range(5):
    print('*' * 7)

print()

for _ in range(5):
    print('*' * 7)

"""І хоча попередній код повністю вирішує поставлене завдання, він не має недоліків. По-перше, він досить громіздкий через повторення частини коду, що відповідає за виведення прямокутника. По-друге, якщо потрібно змінити розміри прямокутника, доведеться змінювати їх тричі, у кожній частині коду, що виводить прямокутник.

Замість повторення коду для виведення прямокутника можна перенести його в окрему **функцію** і викликати її 3 рази.

Для створення функції пишемо такий код:

```python
def draw_box():
    for _ in range(5):
        print('*' * 7)
```

Коли функцію створено, щоб побачити результат її роботи, треба викликати її на ім'я:

```python
draw_box()
```

Тепер, щоб зобразити 3 прямокутники можна написати код:

```python
draw_box()
print()
draw_box()
print()
draw_box()
```

Код став коротшим, читабельнішим (за рахунок вдалої назви функції), а головне, якщо потрібні інші розміри прямокутника, достатньо буде змінити тільки саму функцію `draw_box()`.

<h3 align="center"><b>Найменування функцій</b></h3>

Імена функцій призначаються так само, як змінним. Ім'я функції має бути досить описовим, щоб будь-хто, хто читає ваш код, міг здогадатися, що саме функція робить.

Python і тут вимагає дотримання тих самих правил, що при іменуванні змінних:

1. у імені функції використовуються лише латинські літери a-z, A-Z, цифри та символ нижнього підкреслення (_);
2. ім'я функції не може починатися з цифри;
3. ім'я функції по можливості має відбивати її призначення;
4. символи верхнього та нижнього регістру різняться.

> **Пам'ятай**: Python — регістрочутлива мова. Для найменування змінних і функцій прийнято використовувати стиль **lower_case_with_underscores** (слова з невеликих літер з підкреслення).

Оскільки функції ** виконують дії **, більшість програмістів воліє в іменах функцій **використовувати дієслова**. Наприклад:

* функцію, яка **малює прямокутник** можна назвати `draw_box()`;
* функцію, **яка друкує** чек, можна назвати `print_check()`;
* функцію, яка обчислює заробітну плату до утримань, можна назвати `calculate_gross_рау()`.

Кожне з цих імен дає опис того, що робить функція.

<h3 align="center"><b>Оголошення функції</b></h3>

Отже, **функція – окрема, функціонально незалежна частина програми, що виконує певне завдання.**

Функції оголошуються з допомогою ключового слова `def` (від слова define – визначати). За ключовим словом `def` слідують назва функції, круглі дужки `()`, та двокрапка `:`.

```python
def назва_функції():
    блок коду
```

<div align="center"><img src="https://raw.githubusercontent.com/steamcentre/python_book/main/img/12.png" width="600"></div>

> Перший рядок оголошення функції називається **заголовком функції**.

З наступного рядка йде блок коду – **тіло функції**. Це набір інструкцій, що становлять одне ціле та виконуються щоразу, коли викликається функція.

Зверніть увагу, що кожен рядок у тілі функції виділено відступом.

> Для виділення рядків блоку коду відступом програмісти Python зазвичай використовують **чотири пробіли**, відповідно до стандарту PEP 8.

Розглянемо оголошення функції:

```python
def print_message():
    print('Я - Артур,')
    print('король британців. ')
```

Цей фрагмент коду визначає функцію під назвою `print_message()`. Тіло її складається з двох інструкцій, і виклик призведе до їхнього виконання.

Цей фрагмент коду визначає функцію під назвою `print_message()`. Тіло її складається з двох інструкцій, і виклик призведе до їхнього виконання.

<h3 align="center"><b>Виклик функції</b></h3>

Для виклику функції пишуть її назву та круглі дужки.

> **Важливо**: дуже часто початківці програмісти забувають викликати функцію. Пам'ятайте, що оголошення функції не викликає її.

```python
# оголошення функції
def print_message():
    print('Я - Артур,')
    print('король британців. ')

# виклик функції
print_message()
```

<h3 align="center"><b>Примітки</b></h3>

**Примітка 1**. Зверніть увагу, що оголошення функції користувача трохи нагадує використання умовного оператора if і циклів for, while.

**Примітка 2**. Оголошення функції має **передувати** її виклику. Наступний програмний код:

```python
# виклик функції
print_message()

# оголошення функції
def print_message():
    print('Я - Артур,')
    print('король британцев. ')
```

призведе до помилки:

```python
NameError: name 'print_message' is not defined
```

**Примітка 3**. При оголошенні функції слід переконатися, що кожен рядок функції починається з однакової кількості прогалин, інакше відбудеться помилка. Наприклад, наведене нижче визначення функції призведе до помилки:

```python
def print_greeting():
    рrint('Доброго ранку!')
    рrint('Сьогодні ми вивчатимемо функції.')
    рrint('Це дуже важлива тема!')
```

**Примітка 4**. Іноді, при оголошенні функції, потрібно зробити свого роду заглушку, щоб функція нічого не виконувала. Тоді ми використовуємо ключове слово `pass`:

```python
def do_nothing():
    pass
```

Ми оголосили функцію під назвою `do_nothing()`. Тіло такої функції містить єдиний рядок коду, який нічого не робить.

**Примітка 5**. Функції часто називають підпрограмами.

**Примітка 6**. Присвячується всім, хто забуває викликати функцію та очікує від неї результату:

<div align="center"><img src="https://ucarecdn.com/ae081f0b-e4c6-4bbb-8326-5e00342e81ff/" width="600"></div>

## Тема уроку: функції з параметрами

1. Функції з параметрами
2. Область видимості параметричної змінної
3. Параметри за замовчуванням
4. Розв'язання задач

**Аннотація**. Створення функцій користувача з параметрами.

<h3 align="center"><b>Опції з параметрами</b></h3>

У попередньому уроці ми визначили функцію draw_box(), яка виводить зірковий прямокутник з розмірами 5 × 7:

```python
def draw_box():
    for i in range(5):
        print('*' * 7)
```

Було б набагато зручніше, якби функція draw_box() виводила прямокутник з довільними розмірами. Функції можуть приймати вхідні параметри, що робить їх більш гнучкими.

Функції з параметрами оголошуються як функції без параметрів, лише із зазначенням у дужках:

```python
def назва_функції(параметри):
    блок коду
```

<div align="center"><img src="https://raw.githubusercontent.com/steamcentre/python_book/main/img/13.png" width="600"></div>

Давайте перепишемо попередню версію функції `draw_box()` так, щоб вона приймала параметри, що задають висоту та ширину прямокутника:

```python
def draw_box(height, width):    # функція приймає два параметри
    for i in range(height):
        print('*' * width)
```

Тепер наша функція `draw_box()` приймає два цілих параметри `height` – висота прямокутника та `width` – ширина прямокутника, і для її виклику нам потрібно обов'язково їх вказати.

Щоб вивести зірковий прямокутник розмірами 5 на 7, ми пишемо код:

```python
draw_box(5, 7)
```

Результатом такого виклику функції `draw_box(5, 7)` буде:

```pyton
*******
*******
*******
*******
*******
```

Щоб вивести прямокутник розмірами 10 на 15 ми пишемо код:

```python
draw_box(10, 15)
```

Результатом такого виклику функції `draw_box(10, 15)` буде:

```python
***************
***************
***************
***************
***************
***************
***************
***************
***************
***************
```

Тепер за допомогою нашої нової версії функції `draw_box()` можемо в одній програмі виводити прямокутники різних розмірів. Наступний програмний код:
"""

def draw_box(height, width):
    for i in range(height):
        print('*' * width)


draw_box(3, 3)
print()
draw_box(5, 5)
print()
draw_box(4, 10)

"""На місце параметрів ми можемо підставляти як цілі константи, а й значення змінних. Наступний програмний код:"""

def draw_box(height, width):
    for i in range(height):
        print('*' * width)


n = 3
m = 9
draw_box(n, m)

"""<h3 align="center"><b>Ще приклади</b></h3>

Напишемо функцію `print_hello(n)`, яка приймає одне натуральне число nn і друкує слово `Hello` рівно nn разів.


"""

def print_hello(n):
    print('Hello' * n)

print_hello(3)
print_hello(5)
times = 2
print_hello(times)

"""Функцію `print_hello()` можна зробити більш гнучкою, якщо передавати до неї ще один параметр – текст для виведення:"""

def print_text(txt, n):
    print(txt * n)

print_text('Hello', 5)
print_text('A', 10)

"""<h2 align="center"><b>Параметри VS аргументи</b></h2>

**Аргумент** – це будь-яка порція даних, яка передається у функцію, коли функція викликається. **Параметр** – це змінна, яка отримує аргумент, який передано у функцію.

Для функції `draw_box(height, width)`:

```python
def draw_box(height, width):
    for i in range(height):
        print('*' * width)
```

параметрами є змінні `height` та `width`.

У момент виклику функції `draw_box(height, width)`:

```python
height = 10
draw_box(height, 9)
```

аргументами є `height` та `9`.

> Параметри функцій часто називають **параметричними змінними**.

<h2 align="center"><b>Внесення змін до параметрів</b></h2>

Коли аргумент передається у функцію, параметрична змінна функції посилатиметься на значення цього аргументу. Однак будь-які зміни, що вносяться до параметричної змінної, не впливатимуть на аргумент.

Наступний програмний код:
"""

def draw_box(height, width):
    height = 2
    width = 10
    for i in range(height):
        print('*' * width)

n = 5
m = 7
draw_box(n, m)
print(n, m)

"""У тілі функції вносяться зміни значення параметричних змінних `height` і `width`, проте це ніяк не вплинуло на значення змінних `n` і `m` з основної програми, які передавалися як аргументи в функцію `draw_box()`.

<h2 align="center"><b>Примітка</b></h2>

**Примітка 1**. Функції в Python можуть приймати скільки завгодно параметрів.

**Примітка 2**. Іноді замість параметрів та аргументів говорять про **формальні параметри** та **фактичні параметри**. Формальні параметри – змінні, які ми пишемо під час опису функції. Фактичні параметри – те, що реально підставляється під час виклику функції.

## Тема уроку: локальні та глобальні змінні

1. Локальні змінні
2. Область дії локальної змінної
3. Глобальні змінні
4. Глобальні константи
5. Розв'язання задач

**Аннотація**. Локальні та глобальні змінні.

<h2 align="center"><b>Локальні змінні</b></h2>

**Локальними** називаються змінні, оголошені всередині функції та доступні лише їй самій. Програмний код за межами функції доступу до них не має.

Розглянемо функцію `print_texas()`, яка виводить інформацію про кількість птахів, що мешкають у Техасі.

```python
def print_texas():
    birds = 5000
    print('В Техасі знаходиться', birds, 'птиць.')
```

У тілі функції ми створюємо змінну `birds`, якій надається значення, що дорівнює `5000`. Така змінна є локальною для функції `print_texas()`. Щоразу, коли змінній всередині функції надається значення, у результаті **створюється локальна змінна**. Вона належить до функції, в якій створюється, і до неї отримує доступ лише програмний код цієї функції.

> Термін **"локальна"** вказує на те, що змінна може використовуватися лише в цьому місці - усередині функції, в якій створюється.

Якщо програмний код однієї функції спробує звернутися до локальної змінної, що належить до іншої функції, буде помилка.

Розглянемо наступний програмний код:

```python
def print_texas():
    birds = 5000
    print('В Техасі знаходиться', birds, 'пташок.')

def print_california():
    print('В Каліфорнії знаходиться', birds, 'пташок.')
```

Функция `print_california()` обращается к локальной переменной `birds` функции `print_texas()`. Вызов функции `print_california()`, приводит к ошибке:

```python
NameError: name 'birds' is not defined
```

Локальные переменные скрыты от других функций, поэтому другие функции могут иметь собственные локальные переменные с тем же именем. Например,

```python
def print_texas():
    birds = 5000
    print('В Техасі знаходиться', birds, 'пташок.')

def print_california():
    birds = 9000
    print('В Каліфорнії знаходиться', birds, 'пташок.')
```

У кожній з цих двох функцій є локальна змінна під назвою `birds`. Але вони ніколи не видно одночасно, тому що перебувають у різних функціях.

Коли виконується функція `print_texas()`, видима змінна `birds`, значення якої дорівнює `5000`. Коли виконується функція `print_california()`, видно змінну birds, значення якої дорівнює `9000`.

> Різні функції може мати локальні змінні з однаковими іменами, оскільки де вони бачать локальних змінних одне одного.

<h2 align="center"><b>Область дії змінної</b></h2>

Область дії змінної – частина програми, де можна до неї звертатися, та функція, де створена. Змінна видима лише програмного коду в області її дії. Жодна інструкція за межами функції не може звертатися до такої змінної.

До локальної змінної не може звертатися програмний код, який з'являється всередині функції **до того, як змінна була створена.

Наприклад, якщо у функції `print_texas()` поміняти місцями рядки коду:

```python
def print_texas():
    print('В Техасе знаходиться', birds, 'пташок.')
    birds = 5000
```

то при викликі цієї функції отримаємо помилку:

```python
UnboundLocalError: local variable 'birds' referenced before assignment
```

Помилка виникла внаслідок передчасного звернення до ще не оголошеної локальної змінної `birds`.

<h2 align="center"><b>Область дії параметричної змінної</b></h2>

Область дії параметричної змінної — це функція, в якій цей параметр використовується. До параметричної змінної має доступ весь програмний код цієї функції.

Розглянемо вже відому нам функцію:

```python
def draw_box(height, width):
    for i in range(height):
        print('*' * width)
```

Параметричні змінні тут `height`, `width`. Усередині функції оголошується одна локальна змінна `і`.

<h2 align="center"><b>Примітки</b></h2>

**Примітка 1**. Параметрична змінна також локальна.

**Примітка 2**. Пам'ять для локальних змінних виділяється на час виконання цієї функції у спеціальній області, званій [стеком](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B5%D0%BA). Після завершення роботи функції пам'ять звільняється, внутрішні результати функції не зберігаються від одного звернення до іншого.

<h2 align="center"><b>Глобальні змінні</b></h2>

**Глобальними** називаються змінні, оголошені в основній програмі та доступні як програмі, так і всім її функціям.

Розглянемо наступний програмний код:
"""

birds = 5000    # глобальні змінні

def print_texas():
    print('В Техасе знаходиться', birds, 'пташок.')

def print_california():
    print('В Каліфорнії знаходиться', birds, 'пташок.')

print_texas()
print_california()

"""На самому початку програми створюємо глобальну змінну `birds`, значення якої дорівнює `5000`. Далі описуємо дві функції, які звертаються до глобальної змінної.

> Обмін інформацією між основною програмою та функціями здійснюється лише за допомогою параметрів функцій та глобальних змінних.

Функція може використовувати будь-які глобальні змінні крім тих, що мають ті ж імена, що і її локальні змінні. Якщо функції оголошена локальна змінна з тим самим ім'ям, що з однієї з глобальних, то ця глобальна змінна стає недоступною цієї функції, і за вказівці ідентифікатора змінної відбудеться звернення до локальної змінної функції, а чи не однойменної глобальної.

Розглянемо наступний програмний код:
"""

birds = 5000   # глобальна змінна

def print_texas():
    birds = 1000  # локальна змінна
    print('В Техасі знаходиться', birds, 'пташок.')

def print_california():
    birds = 7000  # локальна змінна
    print('В Калифорнії знаходиться', birds, 'пташок.')

print_texas()
print_california()

"""На самому початку програми ми створюємо глобальну змінну `birds`, значення якої дорівнює `5000`. Далі ми описуємо дві функції, у яких створюються локальні змінні з таким самим ім'ям `birds`. Таким чином, при зверненні до змінної `birds` всередині функцій відбуватиметься звернення саме до локальної змінної.

<h2 align="center"><b>Глобальні змінні - зло</b></h2>

Більшість програмістів згодні, що слід обмежити використання глобальних змінних або використовувати їх взагалі. Причини такі.

* **Глобальні змінні ускладнюють налагодження програми**. Значення глобальної змінної можна змінити будь-якою інструкцією в програмному файлі. Якщо виявиться, що у глобальній змінній зберігається неправильне значення, доведеться знайти всі інструкції, які до неї звертаються, щоб визначити, звідки надходить погане значення. У програмі з тисячами рядків коду це зробити непросто.

* **Функції, що використовують глобальні змінні, зазвичай залежать від цих змінних**. Якщо виникне потреба застосувати таку функцію в іншій програмі, швидше за все, доведеться цю функцію перепроектувати, щоб вона не спиралася на глобальну змінну.

* **Глобальні змінні ускладнюють розуміння програми**. Глобальна змінна може бути модифікована будь-якою інструкцією у програмі. При необхідності розібратися в якійсь частині програми, що використовує глобальну змінну, доведеться дізнатися про всі інші частини програми, що звертаються до цієї глобальної змінної.

> У більшості випадків слід створювати змінні локально і передавати їх як аргументи у функції, яким потрібно до них звернутися.

<h2 align="center"><b>Глобальні константи</b></h2>

Хоча слід уникати використання глобальних змінних, у програмі допускається застосування глобальних констант. Всесвітня константа – світове ім'я, посилається на постійне значення. Оскільки значення глобальної константи не може бути змінено під час виконання програми, можна не турбуватися про потенційні небезпеки, які зазвичай пов'язані з використанням глобальних змінних.

Незважаючи на те, що мова Python не дозволяє створювати реальні глобальні константи, їх можна імітувати за допомогою глобальних змінних. Якщо глобальна змінна не оголошується з використанням ключового слова global всередині функції, то значення, яке їй надано, неможливо змінити всередині цієї функції.

> Математичний модуль `math` визначає дві глобальні змінні, `math.pi` та `math.e`, яким присвоєні математичні значення констант `π = 3.14159265` та `e = 2.71828`.

<h2 align="center"><b>Ключове слово global</b></h2>

Якщо потрібно, щоб інструкція всередині функції надавала значення глобальної змінної, потрібно додатковий крок. У цьому випадку глобальна змінна повинна бути оголошена всередині функції.

Розглянемо наступний програмний код:
"""

знаходитьсяdef print_texas():
    global birds
    birds = 5000
    print('В Техасі знаходиться', birds, 'птиць.')

def print_california():
    print('В Калифорнії знаходиться', birds, 'птиць.')

print_texas()
print_california()

"""## Тема уроку: функції із поверненням значення

1. Функції із поверненням значення
2. Розв'язання задач

**Аннотація**. Функції можуть приймати і приймати параметри, як у прикладах попередніх уроків, а й повертати значення. Розглянемо цей особливий тип функцій – із поверненням значення.

<h2 align="center"><b>Функція із поверненням значення</b></h2>

Функція повернення значення схожа на функцію без повернення значення тим, що:

* це набір інструкцій, що виконує певне завдання;

* коли необхідно виконати функцію, її викликають.

Однак, коли функція з поверненням значення завершується, вона повертає значення в ту частину програми, яка її викликала. Значення, що повертається з функції, використовується як будь-яке інше: воно може бути присвоєне змінною, виведено на екран, використано в математичному вираженні (якщо це число) і т. д.

> Функція повернення значення повертає значення назад у ту частину програми, яка її викликала.

Ми вже стикалися з багатьма функціями із поверненням значень:

функція `int()` - перетворює рядок до цілого числа та повертає його;
функція `float()` – перетворює рядок до речового числа і повертає його;
функція `range()` – повертає послідовність цілих чисел `0, 1, 2, ...`;
функція `abs()` – повертає абсолютне значення числа (модуль числа);
функція `len()` – повертає довжину рядка чи списку.

Функцію з поверненням значення пишуть так само, як і без, але вона повинна мати інструкцію `return`.

Ось загальний формат визначення функції з поверненням значення Python:

```python
def назва_функції():
    блок коду
    return вираз
```

У функції має бути інструкція `return`, що набуває форми:

```python
return вираз
```

Значення виразу, яке слідує за ключовим словом `return`, буде надіслано до частини програми, яка викликала функцію. Це то, можливо змінна чи вираз, наприклад, математичне.

> Функція з поверненням значення має інструкцію `return`, що повертає значення ту частину програми, яка її викликала.

При вивченні дійсних чисел ми вирішували задачу про переведення градусів за шкалою Фаренгейта в градуси за шкалою Цельсія за формулою C = 5/9 (F - 32)

Напишемо функцію, яка здійснює переклад:

```python
def convert_to_celsius(temp):
    result = (5 / 9) * (temp - 32)
    return result
```

Завдання цієї функції – прийняти одне число temp як аргумент – кількість градусів за шкалою Фаренгейта, і повернути інше – кількість градусів за шкалою Цельсія.

Розглянемо її роботу. Перша інструкція в блоці функції надає значення `(5/9)* (temp - 32)` змінній `result`. Потім виконується інструкція `return`, яка призводить до завершення виконання функції та відправляє значення зі змінної `result`, назад у ту частину програми, яка викликала цю функцію.

```python
# функція переведення градусів Фаренгейта в градуси Цельсія
def convert_to_celsius(temp):
    result = (5 / 9) * (temp - 32)
    return result

# основна програма
temp = float(input('Введіть кількість градусів за Фаренгейтом:'))
celsius = convert_to_celsius(temp)
print(celsius)  # градуси Цельсія
```

Основна програма отримує від користувача одне число - значення в градусах Фаренгейта і викликає функцію, передаючи значення змінної `temp` як аргумент. Значення, яке повертається з функції `convert_to_celsius`, надається змінній `celsius`.

<div align="center"><img src="https://raw.githubusercontent.com/steamcentre/python_book/main/img/14.png" width="600"></div>

<div align="center"><img src="https://raw.githubusercontent.com/steamcentre/python_book/main/img/15.png" width="800"></div>

<h2 align="center"><b>Використання інструкції return по максимуму</b></h2>

Поглянемо ще раз на функцію `convert_to_celsius()`:

```python
def convert_to_celsius(temp):
    result = (5 / 9) * (temp - 32)
    return result
```

Зверніть увагу, що всередині цієї функції відбуваються дві речі: по-перше, змінній `result` присвоюється значення виразу `(5/9)* (temp - 32)`, і по-друге, значення змінної `result` повертається з функції. Ця функція добре справляється з поставленим перед нею завданням, але її можна спростити. Оскільки інструкція `return` повертає значення виразу, змінну `result` усуваємо та переписуємо функцію так:

```python
def convert_to_celsius(temp):
    return (5 / 9) * (temp - 32)
```

Ця версія функції не зберігає значення `(5/9)*(temp - 32)` в окремій змінній, а відразу повертає значення виразу за допомогою інструкції `return`. Робить те саме, що й попередня версія, але за один крок.

<h2 align="center"><b>Використання декількох return</b></h2>

В одній функції може бути скільки завгодно інструкцій `return`. Розглянемо функцію `convert_grade()`, яка переводить стобальну оцінку до п'ятибальної:

```python
def convert_grade(grade):
    if grade >= 90:
        return 5
    elif grade >= 80:
        return 4
    elif grade >= 70:
        return 3
    elif grade >= 60:
        return 2
    else:
        return 1

# основна програма
grade = int(input('Введіть вашу позначку за 100-бальною системою: '))
print(convert_grade(grade))
```

У функції `convert_grade()` використовується 5 інструкцій `return`. Кожна з них повертає відповідне значення та завершує роботу функції.

Функцію `convert_grade()` можна переписати за допомогою однієї інструкції `return`:

```python
def convert_grade(grade):
    result = -1
    if grade >= 90:
        result = 5
    elif grade >= 80:
        result = 4
    elif grade >= 70:
        result = 3
    elif grade >= 60:
        result = 2
    else:
        result = 1
    
    return result
```

<h2 align="center"><b>Примітки</b></h2>

**Примітка 1**. Функції повернення значення надають ті ж переваги, що функції без повернення значення:

* Спрощують програмний код;
* зменшують дублювання коду;
* Спрощують тестування коду;
* Збільшують швидкість розробки;
* сприяють роботі у команді.

**Примітка 2**. Графічна інтерпретація роботи функції із поверненням значення:

<div align="center"><img src="https://raw.githubusercontent.com/steamcentre/python_book/main/img/16.png" width="600"></div>

**Примітка 3**. `result` – гарна назва для змінної, значення якої повертається із функції.

## Тема уроку: функції повернення значення

1. Функції із поверненням значення
2. Розв'язання задач

**Аннотація**. Крім функцій, що повертають числові значення, можна писати та повертають логічні, рядкові та інші значення.

<h2 align="center"><b>Повернення булевих значень</b></h2>

Python дозволяє писати [булеві функції](https://ru.wikipedia.org/wiki/%D0%91%D1%83%D0%BB%D0%B5%D0%B2%D0%B0_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F), що повертають або істину (True), або брехню (False). Бульову функцію можна застосовувати для перевірки умови, тоді значення True і False сигналізують про його виконання.

Булеві функції широко застосовуються для спрощення складних умов, що перевіряються у структурах прийняття рішення та структурах з повторенням.
Наприклад, напишемо програму, яка просить користувача ввести число, та визначає парне воно чи непарне.

Це можна зробити так:

```python
number = int(input())
if number % 2 == 0:
    print('Это число четное. ')
else:
    print('Это число нечетное.')
```

Цей фрагмент коду буде легше зрозуміти, якщо написати булеву функцію `is_even()`, яка приймає число як аргумент і повертає True, якщо воно парне, і False якщо непарне.

```python
def is_even(number):
    if number % 2 == 0:
        return True
    else:
        return False
```

Тепер можна переписати інструкцію `if-else` основної програми так, щоб вона для визначення парності змінної `number` викликала функцію `is_even()`:

```python
number = int(input())
if is_even(number):
    print('Это число четное. ')
else:
    print('Это число нечетное.')
```

Так логіку програми легше зрозуміти, а функцію можна викликати у програмі щоразу, коли необхідно перевірити парність числа.

<h2 align="center"><b>Використання булевих функцій для валідації вхідних даних</b></h2>

Булеві функції можна також використовувати для ***спрощення складного коду валідації вхідних даних***. Наприклад, у програмі, що пропонує користувачеві ввести номер моделі виробу, де можливі тільки значення 100, 200 і 300, можемо написати такий код:

```python
model = int(input())

while model != 100 and model != 200 and model != 300:
    рrint('Допустимими номерами моделей є 100, 200 та 300.')
    model = int(input())
```

Цикл валідації використовує довгий складовий булевий вираз, і повторюється до тих пір, поки `model` не дорівнюватиме 100 і 200 або 300.

Разом про те, цикл валідації можна спростити, написавши булеву функцію перевірки змінної `model`, і викликаючи їх у циклі. Напишемо функцію `is_invalid()`, яка приймає один параметр model і повертає значення `True`, якщо модель неприпустима і `False` інакше. Тоді цикл валідації можна переписати так:

```python
while is_invalid(model):
    print('Допустимими номерами моделей є 100, 200 та 300.')
    model = int(input())
```

Після цього зміни циклу стає легше читати. Тепер цілком очевидно, що цикл повторюється доти, доки номер моделі неприпустимий. Нижче наведений фрагмент коду показує, як можна було б написати функцію `is_invalid()`. Вона приймає номер моделі як аргумент, і якщо аргумент не дорівнює 100, 200 і 300, то ця функція повертає `True`, кажучи, що він неприпустимий. Інакше функція повертає `False`.

```python
def is_invalid(model):
    if model != 100 and model != 200 and model != 300:
        return True
    else:
        return False
```

> Створення функцій, що реалізують таку просту логіку — не завжди оптимальне рішення, тому що збільшує розмір коду і веде до витрат часу на виклик функції і повернення результату, що може позначитися на продуктивності програми.

## Тема уроку: функції повернення значення

1. Функції із поверненням кількох значень
2. Розв'язання задач

**Аннотація**. Урок присвячений функціям із поверненням кількох значень.

<h2 align="center"><b>Функції із поверненням кількох значень</b></h2>

У Python функції не обмежені поверненням лише одного значення. Після інструкції return можна визначити багато виразів, розділених комами:

```python
return вираз 1, вираз 2, вираз 3...
```
Наступний програмний код визначає функцію `get_powers(num)`, яка приймає як аргумент число `num` і повертає його квадрат, куб і четвертий ступінь.
"""

def get_powers(num):
    return num**2, num**3, num**4

a, b, c = get_powers(2)
print(a)
print(b)
print(c)

"""Функції, що повертають кілька значень, - виняткова особливість мови Python. У більшості мов програмування для повернення кількох значень використовується результуючий тип даних – список, який може містити кілька значень.

Розглянемо ще один приклад. Нехай потрібно написати функцію, яка знаходить точку перетину двох непаралельних прямих ax + by = e і cx + dy = f. Тобто потрібно вирішити систему рівнянь:

<div align="center"><img src="https://raw.githubusercontent.com/steamcentre/python_book/main/img/17.png" width="600"></div>

Програмний код, який вирішує завдання, має вигляд:

```python
def solve(a, b, c, d, e, f):
    x = (d * e - b * f)/(a * d - b * c)
    y = (a * f - c * e)/(a * d - b * c)
    return x, y
```

Наступний код:
```python
xsol, ysol = solve(2, 3, 4, 1, 2, 5)
print('Рішенням системи є числа', 'x =', xsol, 'y =', ysol)
```
"""

def solve(a, b, c, d, e, f):
    x = (d * e - b * f) / (a * d - b * c)
    y = (a * f - c * e) / (a * d - b * c)
    return x, y

xsol, ysol = solve(2, 3, 4, 1, 2, 5)
print('Рішенням системи є числа', 'x =', xsol, 'y =', ysol)

"""<div align="center"><img src="https://ucarecdn.com/053e7fe8-b707-411a-bc45-080ba285db42/" width="600"></div>

<h2 align="center"><b>Переваги використання функцій</b></h2>

Розбиваючи програми на функції отримуємо:

* **Простіший код**. Розбитий на функції код програми простіше та легше для розуміння. Декілька невеликих функцій набагато легше читати, ніж одну довгу послідовність інструкцій;

* **Повторне використання коду**. Функції дозволяють уникнути багаторазового повторення коду у програмі. Якщо якась операція у програмі виконується у кількох місцях, можна один раз написати для неї функцію і потім виконувати її, коли знадобиться.
* **Просте тестування**. Коли кожна задача у програмі міститься у власній функції, програмісти можуть індивідуально протестувати кожну функцію і визначити, чи вона виконує своє завдання правильно.

* **Швидша розробка**. Припустимо, що програміст чи команда програмістів розробляє багато програм. Вони виявляють загальні завдання різних програм, наприклад з'ясування імені користувача та пароля, виведення поточного часу. Щоразу писати програмний код цих завдань немає сенсу. Для часто зустрічаються завдань пишуть функції, і включають до складу будь-якої програми, що їх потребує.

* **Спрощення командної роботи**. Коли програма розробляється як набір функцій, різним програмістам можна доручити написання окремих функцій.

<h2 align="center"><b>Що виділяти у функції?</b></h2>

У функцію можна виділити будь-який закінчений фрагмент програми. Можна орієнтуватися на рекомендації:

* Коли кілька разів пишете в програмі одну і ту ж послідовність команд, необхідність введення функції набуває характеру гострої внутрішньої потреби;

* Іноді розмаїття дрібниць заступає головне і корисно прибрати в функцію подробиці, що приховують сенс основної програми;

* Корисно розбити довгу програму на складові частини, як книгу розбивають на голови, при цьому основна програма стає схожою на зміст;

* Складні приватні алгоритми буває корисно налагодити окремо в невеликих програмах, що тестують. Включити їх до основної програми буде легко, якщо вони оформлені у вигляді функцій. Наприклад, функції сортувань;

* Зроблене добре в одній програмі, хочеться перенести на нові. Для повторного використання краще відразу виділяти у програмі корисні алгоритми окремі функції, а функції збирати в пакети.

# Джерело

Переклав *Бабенко В.П.* методист цетнру STEAM-освіти

Весь метаріал взятий з курсу "Поколение Python: курс для начинающих", який розташований на платформі [stepik.org](https://stepik.org/) і знаходиться у вільному доступі за [посиланням](https://stepik.org/course/58852/info).

Цей курс знайомить школярів та всіх, кому це цікаво, з програмуванням.

Розповідає про основні типи даних, конструкції та принципи структурного програмування, використовуючи версію мови Python 3.x.

Вибрано Python за ясність коду та швидкість реалізації на ньому програм.

Мета курсу – формування базових понять структурного програмування.

У ньому 8 модулів з теоретичними та практичними матеріалами та завданнями.

**Модулі курсу:**

1. Введення-виведення даних
2. Умовний оператор
3. Типи даних
4. Цикли for та while
5. Рядковий тип даних
6. Списки
7. Функції
8. Робота над міні-проектом

Рішення перевіряє автоматична система, тому зворотний зв'язок ви отримаєте швидко. Якщо у вас виникнуть питання, команда курсу дасть поради та підказки. Крім того, проблеми можна обговорювати з однокурсниками у коментарях до завдань.

Курс – переможець конкурсу Stepik Awards 2020 у номінації "Найкращий безкоштовний онлайн-курс розміщений на платформі Stepik".

Викладачі:

* Тимур Гуєв<br>
Засновник та викладач онлайн-школи BEEGEEK.

* Руслан Чанієв<br>
Адміністратор онлайн-школи BEEGEEK

* Анрі Табуєв<br>
Адміністратор онлайн-школи BEEGEEK
"""