
<h2 align="center"><b>Приклади</b></h2>

**Приклад 1**. Потрібно було написати програму, яка виводить символ А 10 разів. Ви рев'ювіт наступний код:

```python
print('A')
print('A')
print('A')
print('A')
print('A')
print('A')
print('A')
print('A')
print('A')
print('A')
```

Що ви про нього скажете? Чи правильно він працює? Як його покращити?

**Рев'ю**. Наведений код виконує поставлене завдання, проте його можна покращити. Оскільки дії в рядках однакові, можна використовувати цикл. Оскільки ми знаємо кількість повторень (ітерацій), то підходить цикл `for`:

```python
for _ in range(10):
    print('A')
```

**Приклад 2**. Потрібно написати програму яка повинна вивести всі числа від 1 до 100 кратні 7. Ви рев'ювіть наступний код:

```python
i = 1
while i < 101:
    if i % 7 == 0:
        print(i)
        i += 1
```

Що ви про нього скажете? Чи правильно він працює? Як його покращити?

**Рев'ю**. Наведений код містить досить поширену помилку: неправильно поставлений відступ. Оскільки управління циклом `while` відбувається за допомогою змінної `i`, її необхідно інкрементувати (збільшувати) кожну ітерацію. У наведеному коді вона інкрементується тільки якщо виконується умова `i % 7 == 0`, яка є хибною для початкового значення `i = 1`. Отже, отримуємо нескінченний цикл. Для виправлення помилки необхідно видалити відступ у рядка `i += 1`:

```python
i = 1
while i < 101:
    if i % 7 == 0:
        print(i)
    i += 1
```

В даному випадку краще використовувати цикл `for` з кроком, рівним 7. Це дозволить зробити код наочнішим і скоротить час виконання програми, тому що немає необхідності переглядати і перевіряти всі числа на ділимість на 7:

```python
for i in range(7, 101, 7):
    print(i)
```

**Приклад 3**. Потрібно було написати програму, яка виводить усі числа від 100 до 1 у порядку зменшення. Ви рев'ювіт наступний код:

```python
for i in range(1, 100):
    print(101 - i)
```

Що ви про нього скажете? Чи правильно він працює? Як його покращити?

**Рев'ю**. Наведений код містить досить поширену помилку: неправильна права межа циклу `for`. Слід пам'ятати, що правий кордон у циклі `for` завжди не включний. Таким чином, для виправлення помилки необхідно замінити число 100 на 101:

```python
for i in range(1, 101):
    print(101 - i)
```

В даному випадку краще використовувати цикл `for` з кроком, рівним -1:

```python
for i in range(100, 0, -1):
    print(i)
```

**Приклад 4**. Потрібно було написати програму, яка знаходить суму всіх непарних чисел від 1 до 1000. Ви рев'ювіть наступний код:

```python
a = 1
for i in range(1, 1000):
    if i % 2 == 1:
        a = a + 1
print(a)
```

Що ви про нього скажете? Чи правильно він працює? Як його покращити?

**Рев'ю**. Наведений код містить досить поширені помилки:

1. неправильна початкова ініціалізація змінної `a`;
2. неправильна права межа циклу `for`;
3. неправильно записана операція накопичення значення суми.

```python
a = 0
for i in range(1, 1001):
    if i % 2 == 1:
        a = a + i
print(a)
```

Для покращення читабельності коду змінимо назву змінної `a` на `total` і використовуємо розширений оператор присвоєння:

```python
total = 0
for i in range(1, 1001, 2):
    total += i
print(total)
```

**Приклад 5**. Потрібно було написати програму, яка обчислює факторіал числа. Ви рев'ювіт наступний код:

```python
n = input()
a = 0
for i in range(n):
    a = a * i
print(a)
```

Що ви про нього скажете? Чи правильно він працює? Як його покращити?

**Рев'ю**. Наведений код містить досить поширені помилки:

1. відсутність перетворення рядка тексту на ціле число;
2. неправильна початкова ініціалізація змінної `a`;
3. неправильна робота з межами ітерування: змінна `i` набуває значень від 0 до n - 1.

```python
n = int(input())
a = 1
for i in range(1, n + 1):
    a = a * i
print(a)
```

Для покращення читабельності коду, змінимо назву змінної `a` на `factorial` і використовуємо розширений оператор присвоєння:

```python
n = int(input())
factorial = 1
for i in range(1, n + 1):
    factorial *= i
print(factorial)
```

> У модулі `math` є функція `factorial()`, яка обчислює факторіал числа. Тому замість реалізації своєї версії, куди правильніше та зручніше скористатися вже готовою.
